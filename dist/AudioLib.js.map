{"version":3,"sources":["webpack://AudioLib/webpack/universalModuleDefinition","webpack://AudioLib/webpack/bootstrap","webpack://AudioLib/./src/AudioController.js","webpack://AudioLib/./src/AudioLib.js","webpack://AudioLib/./src/RadiusAudio.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4C;AAC5C;AACA;AACA;AACO;AACP;AACA,4BAA4B,wDAAW;AACvC,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,cAAc;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,6BAA6B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qBAAqB;AAChD;AACA,wDAAwD,uCAAuC;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,aAAa;AAC7B;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA,qD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA,aAAa;AACb,iBAAiB;AACjB,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA,yBAAyB;AACzB;AACA,uBAAuB,8BAA8B;AACrD;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,gBAAgB;AAC9B,cAAc,aAAa;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtUA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkD;AACR;;AAE1C;;;;;;;;;;;;;ACnBA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA","file":"AudioLib.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"AudioLib\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"AudioLib\"] = factory();\n\telse\n\t\troot[\"AudioLib\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/AudioLib.js\");\n","/*----------------------------------------------------------------------------------------------------------\r\n::“Copyright 2018 Clayton Burnett”\r\n::This program is distributed under the terms of the GNU General Public License\r\n------------------------------------------------------------------------------------------------------------*/\r\n/**\r\n * @fileOverview\r\n *\r\n * This file contains the implementation for the Audio controller\r\n *\r\n * @author Clayton Burnett <the82professional@hotmail.com>\r\n */\r\n/**\r\n * ###############################################################################################################\r\n *                                              Audio Controller\r\n */\r\n/**\r\n * @class\r\n * Class modeling an Audio controller\r\n *\r\n * @description\r\n * This is the interface for interacting with the page audio controls.  Contains all playing audio\r\n **/\r\nimport { RadiusAudio } from './RadiusAudio';\r\n/**\r\n* @constructor\r\n*/\r\nexport class AudioController {\r\n    constructor(ADChannels) {\r\n        this.includer = new RadiusAudio();\r\n        this.AudioCap = 6; //The maximum number of concurrently playing audio\r\n        this.PlayingAudio = new Array(this.AudioCap);\r\n        //Have to Convert the NodeList to an Array here\r\n        const Elem = document.querySelectorAll(`audio`);\r\n        //this.Channels = Array.prototype.slice.call(Elem);\r\n        this.FreeChannels = Array.prototype.slice.call(Elem, 0) || null;\r\n        this.UsedChannels = new Array();\r\n        this.ClipTimeout = null;\r\n        this.ClipCache = new Array();\r\n        this.Matches = new Array();\r\n        this.Channels = Elem && Elem || null;\r\n    }\r\n    //----------------------------------------------SET METHODS--------------------------------------------------\r\n    /**\r\n    * Sets the list of available page audio clips\r\n    * @param {RadiusAudio[]} Clips An array of current page audio clips\r\n    */\r\n    set UpdateAudioClips(Clips) {\r\n        this.ClipCache = Clips;\r\n    }\r\n    /**\r\n    * Sets the list of available page audio channels that the controller should manage and binds event handlers\r\n    * @param {NodeListOf<HTMLAudioElement>} Channels The Nodelist of Audio Channels to Manage\r\n    */\r\n    set SetAvailableChannels(Channels) {\r\n        if (Channels) {\r\n            this.Channels = Channels;\r\n            let CurrentController = this;\r\n            //----------BEGIN DELETE--------------------\r\n            //Bind channel event listeners(THIS CAN BE DELETED IF NOT USED)\r\n            for (let i = 0; i < Channels.length; i++) {\r\n                //Bind channel event listeners(THIS CAN BE DELETED IF NOT USED)\r\n                Channels[i].onended = function Test(e) { CurrentController.AudioEnded(this, e); };\r\n            }\r\n            //----------END DELETE---------------------\r\n        }\r\n    }\r\n    //----------------------------------------------PLACE EVENT HANDLERS HERE(OR DELETE THIS SECTION)------------------------------------------------\r\n    //---------------BEGIN DELETE------------------------\r\n    /**\r\n    * AudioEnded Event Handler for the Channels(CAN BE DELETED)\r\n    */\r\n    AudioEnded(Ele, Ev) {\r\n        //Dont do anything?\r\n    }\r\n    //--------------END DELETE-----------------------------\r\n    //----------------------------------------------GET METHODS-------------------------------------------------\r\n    /**\r\n    * Get the Array of playing audio channels\r\n    * @returns {Array[]} Returns the Array of playing Audio Channels\r\n    */\r\n    get GetPlayingAudio() {\r\n        return (this.PlayingAudio);\r\n    }\r\n    /**\r\n    * Retrieve a free channel from the pool and then set it to in use\r\n    * @returns {AudioChannel} Free channel\r\n    * Scan and find out if the Audio element is playing on a channel\r\n    * @param {String} ClipName The name of the clip\r\n    * @param {Number} ClipIndex A unique clip index for playing the same clip simultaneously\r\n    */\r\n    RemovePlaying(ClipName, ClipIndex) {\r\n        for (let i in this.PlayingAudio) {\r\n            if (this.PlayingAudio[i].GetFilePath.toString() == ClipName.toString() && this.PlayingAudio[i].GetClipIdentifier == ClipIndex) {\r\n                //We have a match; remove it\r\n                this.PlayingAudio.splice(Number(i), 1);\r\n                //let PreProcess = this.UsedChannels;\t\r\n                //Need to free the channel from UsedChannels Since this is a nodelist must use foreach\r\n                this.UsedChannels.forEach(function (element, index, UsedChannels) {\r\n                    if (element.src == ClipName.toString()) {\r\n                        this.FreeChannels.push(UsedChannels[index]);\r\n                        UsedChannels.splice(index, 1);\r\n                    }\r\n                }, this);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n    * Scan and find out if the Audio element is playing on a channel\r\n    * @param {String} ClipName The name of the clip\r\n    * @param {Number} ClipIndex A unique clip index\r\n    * @typedef RadiusAudio[]\r\n    * @type {Set}\r\n    * @property {RadiusAudio}\r\n    * @returns {RadiusAudio[]} A list of playing items matching the filters\r\n    */\r\n    GetPlayingItems(ClipName, ClipIndex) {\r\n        this.Matches = new Array();\r\n        //9/27/2018 tldr; for-of in TypeScript requires --lib dom, es6 compiler flag but then requires a manual add of each library\r\n        //This is too much work so omitting es6 method of iteration, using c style for for compatibility with Microsoft\r\n        for (let i = 0; i < this.PlayingAudio.length; i++) {\r\n            //The beginning of this statement verifies that the element exists before doing any other evaluations\r\n            if (this.PlayingAudio[i] && this.PlayingAudio[i].GetFilePath == ClipName.toString() && this.PlayingAudio[i].GetClipIdentifier == ClipIndex) {\r\n                //We have a match; add to matches\r\n                this.Matches.push(this.PlayingAudio[i]);\r\n            }\r\n        }\r\n        //After creating match db tally up matches\r\n        if (this.Matches.length == 0) {\r\n            //No Matches Found\r\n            console.log(\"No matches found in GetPlayingItems\");\r\n        }\r\n        return (this.Matches);\r\n    }\r\n    /**\r\n    * Event listener for an audio clip ending\r\n    * @param {AudioController} instance A pointer to the running AudioController instance\r\n    * @param {DOMElement[]} Channels A reference to the array of Audio channels from DOM\r\n    */\r\n    /*private AudioEnded(instance: AudioController, Channels: HTMLAudioElement[]){\r\n        if(instance != null){\r\n            let Audio = instance.PlayingAudio;\r\n            let Free = instance.FreeChannels;\r\n            for(let i of this.PlayingAudio){\r\n                let item = i.GetFilePath; //Yes no parens are correct syntax\r\n                if(item == Channels.getAttribute().currentTarget.currentSrc){\r\n                    //We've found the audio item so release the controller\r\n                    let controller = Audio[i].GetController();\r\n                    Free.push(controller);\r\n                    Audio.splice(i, 1);\r\n                }\r\n            }\r\n        }\r\n    }*/\r\n    /**\r\n    * Stop all playing audio and reset the Audio Controller to a neutral state\r\n    */\r\n    Clean() {\r\n        //Stop all playing Audio\r\n        for (let i of this.UsedChannels) {\r\n            i.pause();\r\n        }\r\n        this.PlayingAudio = null;\r\n        this.Channels = null;\r\n        this.FreeChannels = null;\r\n        this.UsedChannels = null;\r\n        this.ClipTimeout = null;\r\n        this.ClipCache = null;\r\n    }\r\n    /**\r\n    * checks to make sure there is a free channel and reserves it\r\n    * @returns {HTMLAudioElement} Returns a reference to a free Audio Element\r\n    */\r\n    GetFreeChannel() {\r\n        if (this.FreeChannels.length > 0) {\r\n            //There Are channels available, allocate\r\n            let channel = this.FreeChannels.pop();\r\n            this.UsedChannels.push(channel);\r\n            return (channel);\r\n        }\r\n        else {\r\n            console.log(\"Allocation Error: No more free channels\");\r\n        }\r\n    }\r\n    /**\r\n    * Add the RadiusAudio element to the array of playing Audio\r\n    * @param {RadiusAudio} Audio Audio element to add to the list of playing audio tracks\r\n    */\r\n    AddToPlaying(Audio) {\r\n        //Remove the first Array Element and Stop Audio\r\n        /*if(this.PlayingAudio[0]){\r\n            this.Stop(this.PlayingAudio[0].GetFilePath.toString(), this.PlayingAudio[0].GetClipIdentifier);\r\n        }\r\n        this.PlayingAudio.splice(0, 1);*/\r\n        //Add to the end, officially making it a queue\r\n        this.PlayingAudio.push(Audio);\r\n    }\r\n    //--------------------PUBLIC INTERFACE FUNCTIONS-----------------\r\n    /**\r\n    * Play a clip from a RadiusAudio object\r\n    * @param {String} ClipName The name of the clip\r\n    * @param {Number} ClipIndex A unique clip index for playing the same clip simultaneously\r\n    */\r\n    //LOGIC FLOW\r\n    //*Get a free channel\r\n    //*Assign variables to the free channel\r\n    //*Set the channel to play\r\n    //*Add Channel to the list of playing Channels\r\n    PlayAudio(ClipName, ClipIndex) {\r\n        let exist = this.GetPlayingItems(ClipName, ClipIndex);\r\n        //1st thing check for a duplicate entry \r\n        if (exist.length == 0 && this.GetPlayingAudio) {\r\n            //Get a free channel remember to release when done\r\n            let Channel = this.GetFreeChannel();\r\n            //0 indicates no channels free\r\n            if (Channel) {\r\n                for (let i of this.ClipCache) {\r\n                    if (i.GetFilePath.toString() == ClipName) {\r\n                        //We found it so assign it \r\n                        i.SetClipIdentifier = ClipIndex;\r\n                        this.AddToPlaying(i);\r\n                        Channel.src = i.GetFilePath.toString();\r\n                        Channel.play();\r\n                    }\r\n                    else {\r\n                        //There was no clip matching ClipName\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                alert(\"Out of free channels\");\r\n                //No free channels\r\n            }\r\n        }\r\n    }\r\n    /**\r\n    * Skips to the current time value in seconds given by \"Value\"\r\n    * @param {String} ClipName The name of the clip\r\n    * @param {Number} ClipIndex A unique clip index\r\n    * @param {Float} Value The track starting position in seconds\r\n    */\r\n    //LOGIC FLOW\r\n    //*Search the list of playing channels for the name and index\r\n    //*If we find it then stop the track and set the start time to Value\r\n    //*Set the channel to play\r\n    SkipTo(ClipName, ClipIndex, Value) {\r\n        let Playing = this.GetPlayingAudio;\r\n        let Matches = Array();\r\n        for (let i of Playing) {\r\n            if (i.GetFilePath == ClipName && i.GetClipIdentifier == ClipIndex) {\r\n                //We have a match; add to matches\r\n                Matches.push(i);\r\n                //set seek\r\n                i.SetTrackPos(Value);\r\n            }\r\n        }\r\n        //After creating match db tally up matches\r\n        if (Matches.length == 0) {\r\n            //No Matches Found\r\n            console.log(\"No matches found in SkipTo\");\r\n        }\r\n    }\r\n    /**\r\n    * Stops audio associated with the object on the associated controller\r\n    * @param {String} ClipName The name of the clip\r\n    * @param {Number} ClipIndex A unique clip index\r\n    */\r\n    //LOGIC FLOW\r\n    //*Search the list of playing channels for the name and index\r\n    //*Stop the specified controller\r\n    //*Remove the channel from the list of playing channels\r\n    Stop(ClipName, ClipIndex) {\r\n        let PlayingChannels = this.UsedChannels;\r\n        let PlayingAudio = this.GetPlayingItems(ClipName, ClipIndex);\r\n        //Only stop if there are matches\r\n        if (PlayingAudio.length > 0) {\r\n            for (let i of PlayingChannels) {\r\n                //Make sure the audio is registered to a channel and playing\r\n                if (i.src == ClipName.toString() && i.paused != true) {\r\n                    i.pause;\r\n                    //Remove the clip from the list\r\n                    this.RemovePlaying(ClipName, ClipIndex);\r\n                    //Don't forget to stop the clip on the channel\r\n                    var found = false;\r\n                    this.Channels.forEach(function (element) {\r\n                        if (element.src == ClipName.toString() && found == false) {\r\n                            //Just remove the first one encountered\r\n                            element.pause();\r\n                            element.currentTime = 0;\r\n                            found = true;\r\n                        }\r\n                    });\r\n                    console.log(\"stopped one audio track\");\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            console.log(\"Could Not Stop audio clip because there were no matches\");\r\n        }\r\n    }\r\n    /**\r\n    * Sets the specified audio clip to repeat\r\n    * @param {String} ClipName The name of the clip\r\n    * @param {Number} ClipIndex A unique clip index\r\n    * @param {Boolean} RepeatFlag Boolean flag to set the clip to repeating\r\n    */\r\n    //LOGIC FLOW\r\n    //*Search the list of playing channels for the name and index\r\n    //*If we find it then set the repeating flag\r\n    SetRepeating(ClipName, ClipIndex, Flag) {\r\n        let Channels = this.UsedChannels;\r\n        let AudioOBJ = this.GetPlayingItems;\r\n        if (this.Matches.length > 0) {\r\n            //we have a match so \r\n            for (let i of this.Matches) {\r\n                i.SetRepeating(Flag);\r\n                //Search the running Channels for the first instance\r\n                let instance = Channels.filter(Running => Running.src === ClipName)[0];\r\n                //Set the flag\r\n                instance.loop = Flag;\r\n            }\r\n        }\r\n        else {\r\n            //No matches\r\n            console.log(\"Cant Set Repeating flag: unknown clipname or index\");\r\n        }\r\n    }\r\n}\r\n","/*----------------------------------------------------------------------------------------------------------\r\n::“Copyright 2018 Clayton Burnett”\r\n::This program is distributed under the terms of the GNU General Public License\r\n------------------------------------------------------------------------------------------------------------*/\r\n/**\r\n * @fileOverview\r\n *\r\n * This file contains the entry point for the Audio Library\r\n *\r\n * @author Clayton Burnett <the82professional@hotmail.com>\r\n */\r\n/**\r\n * ###############################################################################################################\r\n *                                              AudioLib\r\n */\r\n//Importing Dependencies\r\nimport {AudioController} from \"./AudioController\";\r\nimport {RadiusAudio} from \"./RadiusAudio\";\r\n\r\n//Passthrough classes\r\nexport{AudioController, RadiusAudio};","/*----------------------------------------------------------------------------------------------------------\r\n::“Copyright 2018 Clayton Burnett”\r\n::This program is distributed under the terms of the GNU General Public License\r\n------------------------------------------------------------------------------------------------------------*/\r\n/**\r\n * @fileOverview\r\n *\r\n * This file contains the main object implementing audio controls for the HTML5 Audio player\r\n *\r\n * @author Clayton Burnett <the82professional@hotmail.com>\r\n */\r\n/**\r\n * ###############################################################################################################\r\n *                                              RadiusAudio\r\n */\r\n/**\r\n * @class\r\n * Class modeling an Audio clip\r\n *\r\n * @description\r\n * The current audio output tag is operated through this Audio class\r\n **/\r\n/**\r\n* @constructor\r\n*/\r\nexport class RadiusAudio {\r\n    constructor(TVZ_AudioFile, TVZ_Volume, TVZ_Duration, TVZ_Format) {\r\n        this.TVZ_AudioFile = TVZ_AudioFile;\r\n        this.TVZ_Volume = TVZ_Volume;\r\n        this.TVZ_Duration = TVZ_Duration;\r\n        this.TVZ_Format = TVZ_Format;\r\n        //Default overloaded Constructor\r\n        this.AudioFile = TVZ_AudioFile && new String(TVZ_AudioFile) || \"\";\r\n        this.RepeatingFlag = false;\r\n        this.Volume = TVZ_Volume && TVZ_Volume || 0.0;\r\n        this.Duration = TVZ_Duration && TVZ_Duration || 0.0;\r\n        this.Format = TVZ_Format && new String(TVZ_Format) || \"mp3\";\r\n        this.Playing = false;\r\n        this.SavedTrack = 0.0;\r\n        this.ID = 0.0;\r\n    }\r\n    //-------------------------------------------------------------SET METHODS---------------------------\r\n    /**\r\n    * Set Repeat flag\r\n    * @param {Boolean} Repeat Sets the Audio clip to either repeat or not repeat\r\n    */\r\n    set SetRepeating(Repeat) {\r\n        this.RepeatingFlag = Repeat;\r\n    }\r\n    /**\r\n    * Set Timeout\r\n    * @param {Array[]} MinutesAndSeconds Sets the Audio clip timeout\r\n    */\r\n    set SetClipTimeout(MinutesAndSeconds) {\r\n        this.Duration = MinutesAndSeconds;\r\n    }\r\n    /**\r\n    * Sets the current playtime value in seconds given by \"Value\"\r\n    * @param {Float} Value The track starting position in seconds\r\n    */\r\n    set SetTrackPos(Seconds) {\r\n        this.SavedTrack = Seconds;\r\n    }\r\n    /**\r\n    * Sets the unique instance ID of the Audio object for playing the same clip simultaneously\r\n    * @param {number} ID A unique number ID\r\n    */\r\n    set SetClipIdentifier(ID) {\r\n        this.ID = ID;\r\n    }\r\n    //----------------------------------------------------------GET METHODS-------------------------------\r\n    /**\r\n   * Sets the unique instance ID of the Audio object for playing the same clip simultaneously\r\n   * @returns {Number} The unique number ID\r\n   */\r\n    get GetClipIdentifier() {\r\n        return (Number(this.ID));\r\n    }\r\n    /**\r\n    * Gets the current playtime value in seconds given by \"Value\"\r\n    * @returns {Float} The current track position in seconds\r\n    */\r\n    get GetTrackPos() {\r\n        return (this.SavedTrack);\r\n    }\r\n    /**\r\n    * Get Timeout\r\n    * @returns {Array[]} Gets the Audio clip timeout\r\n    */\r\n    get GetClipTimeout() {\r\n        return (this.Duration);\r\n    }\r\n    /**\r\n    * Get the Audio file string\r\n    * @returns {String} Returns the AudioFile path contained in the audio object\r\n    */\r\n    get GetFilePath() {\r\n        return (this.AudioFile);\r\n    }\r\n}\r\n"],"sourceRoot":""}